# Fantasy Finance

## Description

Fantasy Finance is a "Paper Trading Platform". It emulates a real-life stock trading environment without the risk of losing funds as it deals exclusively with fake money.

The purpose of such a platform is to give beginner traders the confidence to explore the world of invesments and trading, and for more advanced traders to experiment with new strategies, risk-free.

## Time Frame

The time frame for this project was 2 weeks.

## Technologies Used

### API's

- AlphaVantage

###  Back End

- Ruby On Rails
- HTTParty
- Devise

### Front End

- React
- React Router Dom
- JavaScript
- Axios
- Bootstrap

## Brief

The brief for this project was as follows:

### Requirements
- Build a full stack web application. Must be your own work.
- Select a Project Idea of your own.
- Have at least 2 models (more if it makes sense)
- Auth is a requirement
- Have full CRUD on at least one of your models
- Be able to Add/Delete on any remaining models

#### Have high quality code:
- Follow accepted naming conventions
- Consistent indentation
- Well-structured and readable code
- Semantic naming of variables, functions, CSS classes, etc.
- Short and clear functions that do one thing
- Efficient code - if you have your MVP, refactor
- DRY (Don't Repeat Yourself) code

#### Use one of these technology stacks. You may choose which tech stack.

- Full-Stack Rails App
- Rails API with React Front-End
- Express API with React Front-End
- Be deployed on Heroku or similar platform
- Craft a README.md file that explains your app.

#### Necessary Deliverables
- Submissions will be submitted by posting into a Google Sheet

- a link to your deployed application(s)
- a link to your github repo(s)

#### The presentation must be a 5-10 minute presentation in which you answer the following questions:

- What is the application about?
- What are the user stories for your application?
- What API did you choose to use, if any?
- Demo of the application
- Walk through a piece of code
- What was the most difficult part of the project?
- What was your favorite part of the project
- What would your team like to add next?

#### Stretch Goals
- Use a 3rd party API
- Mobile Responsive
- High quality, professional design
- Redux
- Automated Tests Using Jest / RSpec or MiniTest for Rails


##  Planning

My planning consisted of three main stages.

1) I created basic structure of what each page should containn and desired user stories. I then listed which CRUD operations they satisfied, for example:

I need to have a profile page with my; 

- Age - C
- Card details - C/R/U/D
- Name - C/U
- Email - C/U/D
- Bio - C/U/D
- Trading style - C/U
- Experience level - C
- Funds - C/R/U/D
- Photo - C/D

2) I mapped out a wireframe to make sure all features would work in sync, and this step also helped to jog new ideas/features in my mind.

#### Wireframe
<img src="./proposal/wireframe.png">

3) I created a list of relationships and associations for each model. Along with all the routes I anticipated having to create. This would serve as a base from which I could build.


#### Models

- User
    - Name : string
    - Age : integer
    - Email : string
    - ProfilePicture : string (url)
    - card details
        - generated by third party api
    - tradingStyle : string
    - experienceLevel : string
    - balance : integer

#### Associations

```ruby
class User < ApplicationRecord
  has_many :watchlists
  has_many :holdings
  has_many :stocks, through: :holdings
	has_many :trades
end

class Stock < ApplicationRecord
	has_many :watchlist_stocks
  has_many :watchlists, through: :watchlist_stocks
  has_many :holdings
  has_many :users, through: :holdings
	has_many :trades
end
```

## Build/Code Process

### Back End

Building out the routes and controllers for the application was a really enjoyable yet challenging part of the project for me.

Whilst back end coding certainly comes more intuitively to me, it wasn't without it's challenges!

The below code snippet shows the route and action required to add a specific stock to a users pre-made watchlist.

For every route i started with the top section of code, defining the end point and designating the name of the following action.

Next I would build the controller. This controller was the first I made which would involve the shovel operator. Whilst going through the process this solution didn't immediately come to mind, so whilst it looks fairly simple I was quite proud of coming to this conclusion.

Assigning the appropriate watchlist and stock was the first step, then designing the "if" statement came next.

Prior to a bit of searching on stack overflow, I didn't attempt this with "if" statements.

```ruby
# routes.rb
  post "user/:user_id/watchlist/:watchlist_id/:symbol", to: "watchlists#populate_watchlist"


# watchlist_controller.rb

#  Populate a watchlist with a stock
def populate_watchlist
    @watchlist = @user.watchlists.find(params[:watchlist_id])
    @stock = Stock.find_by(symbol: params[:symbol])
    if @watchlist.stocks << @stock
        render json: @watchlist, status: :created
    else
        render json: @watchlist.errors, status: :unprocessable_entity
    end
end
```

### Front End

#### Consuming the API Endpoints

Maxing use of the Axios package to manage API calls was the first thing I did on the front end after setting up the boilerplate code.

I opted to use Axios rather than the inbuilt 'fetch' syntax because the format is far more intuitive to me. Furthermore, being able to set up an axiosInstance (see below) made the readability easier.

As for the actual implementation, the createUser function below was quite a painstaking process! It was the first time in trying to hook up Axios with the Devise gem in the back end, and also the first time configuring anything in Local Storage. 

Understanding the sequencing, specifically when the token is created and when it must be saved to local storage, took quite a lot of thinking and research. I played around with including a headers/authorization token in the axiosInstance along with structuring it as you see below.

```js
export const createUser = async (userData) => {
    if (!userData) {
        return
    } else {
    console.log("USER DATA: ",userData);
    const response = await axiosInstance.post("/signup",{user: userData});
    console.log("TOKEN: ", response.headers.authorization);
    if (response.headers.authorization) {
        window.localStorage.setItem("token", response.headers.authorization);

    }
    return response.data;
}}
```

```js
// Configuring the Axios Instance for the API

import axios from 'axios';

const axiosInstance = axios.create({
    baseURL: "http://localhost:4000",
    headers: {
        'Content-Type': 'application/json'
    },
});

export default axiosInstance;
```

##  Challenges

### Back End

Setting up this route/action was quite the challenge. Initially I wasn't mapping over the holdings variable and instead was just returning the holdings object which represents the model.

To achieve the proper user story, when you have bought a stock you would want to see the name, ticker, purchase price etc rather than just "stock_id: 1" etc, which was what I was dealing with.

The solution of mapping over the holdings variable is quite a simple one, but it didn't occur to me that this was the correct approach in the back end. Prior to this, in my mind a map was only for use on the front end, so i'm glad I was stuck on it!

```ruby
# routes.rb
get "user/:user_id/holdings", to: "holdings#all_holdings"


# watchlist_controller.rb
# Get all holdings belonging to the current user
    def all_holdings
        holdings = @user.holdings.includes(:stock)
        holdings_with_stocks = holdings.map do |holding|
            {
                id: holding.id,
                quantity: holding.quantity,
                purchase_price: holding.purchase_price,
                created_at: holding.created_at,
                updated_at: holding.updated_at,
                stock: {
                        id: holding.stock.id,
                        company_name: holding.stock.company_name,
                        symbol: holding.stock.symbol,
                        exchange: holding.stock.exchange,
                        sector: holding.stock.sector,
                        market_capitalization: holding.stock.market_capitalization,
                        description: holding.stock.description,
                        Quarterly_Earnings_Growth_YOY: holding.stock.Quarterly_Earnings_Growth_YOY,
                        Quarterly_Revenue_Growth_YOY: holding.stock.Quarterly_Revenue_Growth_YOY
                       }
            }
end
        render json: holdings_with_stocks
    
end
```

###  Front End

Building on the createUser function discussed earlier, I faced a rather elusive challenge when testing the functionality.

My initial strategy for testing this function was to pass the userData via consoleLog. The problem was that even though I was setting unique values for each field, i'd get an error message explaining duplicate information wasn't valid!

After making sure that the routes and actions in the back end were correct, I found the issue was due to the inbuilt Strict Mode in React, which was causing the request to be sent twice with the same information. After commenting those lines out in index.js, everything worked as expected.

The lesson I learned here was to think past what may seem to be the most convienient soltuin for testing, and use the testing method which most closely represents the result I want to achieve.

For example, I should have built a 'bare bones' form and use that to submit the test rather than the consoleLog.

```js
export const createUser = async (userData) => {
    if (!userData) {
        return
    } else {
    console.log("USER DATA: ",userData);
    const response = await axiosInstance.post("/signup",{user: userData});
    console.log("TOKEN: ", response.headers.authorization);
    if (response.headers.authorization) {
        window.localStorage.setItem("token", response.headers.authorization);

    }
    return response.data;
}}
```